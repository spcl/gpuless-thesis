// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EXECUTIONPROTOCOL_GPULESS_EXECUTION_H_
#define FLATBUFFERS_GENERATED_EXECUTIONPROTOCOL_GPULESS_EXECUTION_H_

#include "flatbuffers/flatbuffers.h"

#include "cudevice_attributes_generated.h"

namespace gpuless {
namespace execution {

struct KernelArgument;
struct KernelArgumentBuilder;

struct Dim3;

struct ExecutionRequest;
struct ExecutionRequestBuilder;

struct ReturnBuffer;
struct ReturnBufferBuilder;

struct ExecutionAnswer;
struct ExecutionAnswerBuilder;

struct CUdeviceAttributeValue;
struct CUdeviceAttributeValueBuilder;

struct AttributesAnswer;
struct AttributesAnswerBuilder;

struct AttributesRequest;
struct AttributesRequestBuilder;

struct ProtocolMessage;
struct ProtocolMessageBuilder;

enum Status : int8_t {
  Status_OK = 0,
  Status_FAILURE = 1,
  Status_MIN = Status_OK,
  Status_MAX = Status_FAILURE
};

inline const Status (&EnumValuesStatus())[2] {
  static const Status values[] = {
    Status_OK,
    Status_FAILURE
  };
  return values;
}

inline const char * const *EnumNamesStatus() {
  static const char * const names[3] = {
    "OK",
    "FAILURE",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatus(Status e) {
  if (flatbuffers::IsOutRange(e, Status_OK, Status_FAILURE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStatus()[index];
}

enum Message : uint8_t {
  Message_NONE = 0,
  Message_ExecutionRequest = 1,
  Message_ExecutionAnswer = 2,
  Message_AttributesRequest = 3,
  Message_AttributesAnswer = 4,
  Message_MIN = Message_NONE,
  Message_MAX = Message_AttributesAnswer
};

inline const Message (&EnumValuesMessage())[5] {
  static const Message values[] = {
    Message_NONE,
    Message_ExecutionRequest,
    Message_ExecutionAnswer,
    Message_AttributesRequest,
    Message_AttributesAnswer
  };
  return values;
}

inline const char * const *EnumNamesMessage() {
  static const char * const names[6] = {
    "NONE",
    "ExecutionRequest",
    "ExecutionAnswer",
    "AttributesRequest",
    "AttributesAnswer",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessage(Message e) {
  if (flatbuffers::IsOutRange(e, Message_NONE, Message_AttributesAnswer)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessage()[index];
}

template<typename T> struct MessageTraits {
  static const Message enum_value = Message_NONE;
};

template<> struct MessageTraits<gpuless::execution::ExecutionRequest> {
  static const Message enum_value = Message_ExecutionRequest;
};

template<> struct MessageTraits<gpuless::execution::ExecutionAnswer> {
  static const Message enum_value = Message_ExecutionAnswer;
};

template<> struct MessageTraits<gpuless::execution::AttributesRequest> {
  static const Message enum_value = Message_AttributesRequest;
};

template<> struct MessageTraits<gpuless::execution::AttributesAnswer> {
  static const Message enum_value = Message_AttributesAnswer;
};

bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type);
bool VerifyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Dim3 FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t x_;
  uint64_t y_;
  uint64_t z_;

 public:
  Dim3()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Dim3(uint64_t _x, uint64_t _y, uint64_t _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  uint64_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  uint64_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
  uint64_t z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Dim3, 24);

struct KernelArgument FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef KernelArgumentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_FLAGS = 6,
    VT_BUFFER = 8
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  const flatbuffers::Vector<uint8_t> *buffer() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BUFFER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           VerifyOffset(verifier, VT_BUFFER) &&
           verifier.VerifyVector(buffer()) &&
           verifier.EndTable();
  }
};

struct KernelArgumentBuilder {
  typedef KernelArgument Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(KernelArgument::VT_ID, id);
  }
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(KernelArgument::VT_FLAGS, flags, 0);
  }
  void add_buffer(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> buffer) {
    fbb_.AddOffset(KernelArgument::VT_BUFFER, buffer);
  }
  explicit KernelArgumentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<KernelArgument> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KernelArgument>(end);
    return o;
  }
};

inline flatbuffers::Offset<KernelArgument> CreateKernelArgument(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    int32_t flags = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> buffer = 0) {
  KernelArgumentBuilder builder_(_fbb);
  builder_.add_buffer(buffer);
  builder_.add_flags(flags);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<KernelArgument> CreateKernelArgumentDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    int32_t flags = 0,
    const std::vector<uint8_t> *buffer = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto buffer__ = buffer ? _fbb.CreateVector<uint8_t>(*buffer) : 0;
  return gpuless::execution::CreateKernelArgument(
      _fbb,
      id__,
      flags,
      buffer__);
}

struct ExecutionRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExecutionRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KERNEL = 4,
    VT_CUDA_BIN = 6,
    VT_ARGUMENTS = 8,
    VT_DIM_GRID = 10,
    VT_DIM_BLOCK = 12
  };
  const flatbuffers::String *kernel() const {
    return GetPointer<const flatbuffers::String *>(VT_KERNEL);
  }
  const flatbuffers::Vector<uint8_t> *cuda_bin() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CUDA_BIN);
  }
  const flatbuffers::Vector<flatbuffers::Offset<gpuless::execution::KernelArgument>> *arguments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<gpuless::execution::KernelArgument>> *>(VT_ARGUMENTS);
  }
  const gpuless::execution::Dim3 *dim_grid() const {
    return GetStruct<const gpuless::execution::Dim3 *>(VT_DIM_GRID);
  }
  const gpuless::execution::Dim3 *dim_block() const {
    return GetStruct<const gpuless::execution::Dim3 *>(VT_DIM_BLOCK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KERNEL) &&
           verifier.VerifyString(kernel()) &&
           VerifyOffset(verifier, VT_CUDA_BIN) &&
           verifier.VerifyVector(cuda_bin()) &&
           VerifyOffset(verifier, VT_ARGUMENTS) &&
           verifier.VerifyVector(arguments()) &&
           verifier.VerifyVectorOfTables(arguments()) &&
           VerifyField<gpuless::execution::Dim3>(verifier, VT_DIM_GRID) &&
           VerifyField<gpuless::execution::Dim3>(verifier, VT_DIM_BLOCK) &&
           verifier.EndTable();
  }
};

struct ExecutionRequestBuilder {
  typedef ExecutionRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kernel(flatbuffers::Offset<flatbuffers::String> kernel) {
    fbb_.AddOffset(ExecutionRequest::VT_KERNEL, kernel);
  }
  void add_cuda_bin(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> cuda_bin) {
    fbb_.AddOffset(ExecutionRequest::VT_CUDA_BIN, cuda_bin);
  }
  void add_arguments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<gpuless::execution::KernelArgument>>> arguments) {
    fbb_.AddOffset(ExecutionRequest::VT_ARGUMENTS, arguments);
  }
  void add_dim_grid(const gpuless::execution::Dim3 *dim_grid) {
    fbb_.AddStruct(ExecutionRequest::VT_DIM_GRID, dim_grid);
  }
  void add_dim_block(const gpuless::execution::Dim3 *dim_block) {
    fbb_.AddStruct(ExecutionRequest::VT_DIM_BLOCK, dim_block);
  }
  explicit ExecutionRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ExecutionRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExecutionRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExecutionRequest> CreateExecutionRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> kernel = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> cuda_bin = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<gpuless::execution::KernelArgument>>> arguments = 0,
    const gpuless::execution::Dim3 *dim_grid = 0,
    const gpuless::execution::Dim3 *dim_block = 0) {
  ExecutionRequestBuilder builder_(_fbb);
  builder_.add_dim_block(dim_block);
  builder_.add_dim_grid(dim_grid);
  builder_.add_arguments(arguments);
  builder_.add_cuda_bin(cuda_bin);
  builder_.add_kernel(kernel);
  return builder_.Finish();
}

inline flatbuffers::Offset<ExecutionRequest> CreateExecutionRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *kernel = nullptr,
    const std::vector<uint8_t> *cuda_bin = nullptr,
    const std::vector<flatbuffers::Offset<gpuless::execution::KernelArgument>> *arguments = nullptr,
    const gpuless::execution::Dim3 *dim_grid = 0,
    const gpuless::execution::Dim3 *dim_block = 0) {
  auto kernel__ = kernel ? _fbb.CreateString(kernel) : 0;
  auto cuda_bin__ = cuda_bin ? _fbb.CreateVector<uint8_t>(*cuda_bin) : 0;
  auto arguments__ = arguments ? _fbb.CreateVector<flatbuffers::Offset<gpuless::execution::KernelArgument>>(*arguments) : 0;
  return gpuless::execution::CreateExecutionRequest(
      _fbb,
      kernel__,
      cuda_bin__,
      arguments__,
      dim_grid,
      dim_block);
}

struct ReturnBuffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReturnBufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_BUFFER = 6
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::Vector<uint8_t> *buffer() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BUFFER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_BUFFER) &&
           verifier.VerifyVector(buffer()) &&
           verifier.EndTable();
  }
};

struct ReturnBufferBuilder {
  typedef ReturnBuffer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(ReturnBuffer::VT_ID, id);
  }
  void add_buffer(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> buffer) {
    fbb_.AddOffset(ReturnBuffer::VT_BUFFER, buffer);
  }
  explicit ReturnBufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ReturnBuffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReturnBuffer>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReturnBuffer> CreateReturnBuffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> buffer = 0) {
  ReturnBufferBuilder builder_(_fbb);
  builder_.add_buffer(buffer);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReturnBuffer> CreateReturnBufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const std::vector<uint8_t> *buffer = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto buffer__ = buffer ? _fbb.CreateVector<uint8_t>(*buffer) : 0;
  return gpuless::execution::CreateReturnBuffer(
      _fbb,
      id__,
      buffer__);
}

struct ExecutionAnswer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExecutionAnswerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATUS = 4,
    VT_RETURN_BUFFERS = 6
  };
  gpuless::execution::Status status() const {
    return static_cast<gpuless::execution::Status>(GetField<int8_t>(VT_STATUS, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<gpuless::execution::ReturnBuffer>> *return_buffers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<gpuless::execution::ReturnBuffer>> *>(VT_RETURN_BUFFERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_STATUS) &&
           VerifyOffset(verifier, VT_RETURN_BUFFERS) &&
           verifier.VerifyVector(return_buffers()) &&
           verifier.VerifyVectorOfTables(return_buffers()) &&
           verifier.EndTable();
  }
};

struct ExecutionAnswerBuilder {
  typedef ExecutionAnswer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status(gpuless::execution::Status status) {
    fbb_.AddElement<int8_t>(ExecutionAnswer::VT_STATUS, static_cast<int8_t>(status), 0);
  }
  void add_return_buffers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<gpuless::execution::ReturnBuffer>>> return_buffers) {
    fbb_.AddOffset(ExecutionAnswer::VT_RETURN_BUFFERS, return_buffers);
  }
  explicit ExecutionAnswerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ExecutionAnswer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExecutionAnswer>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExecutionAnswer> CreateExecutionAnswer(
    flatbuffers::FlatBufferBuilder &_fbb,
    gpuless::execution::Status status = gpuless::execution::Status_OK,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<gpuless::execution::ReturnBuffer>>> return_buffers = 0) {
  ExecutionAnswerBuilder builder_(_fbb);
  builder_.add_return_buffers(return_buffers);
  builder_.add_status(status);
  return builder_.Finish();
}

inline flatbuffers::Offset<ExecutionAnswer> CreateExecutionAnswerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    gpuless::execution::Status status = gpuless::execution::Status_OK,
    const std::vector<flatbuffers::Offset<gpuless::execution::ReturnBuffer>> *return_buffers = nullptr) {
  auto return_buffers__ = return_buffers ? _fbb.CreateVector<flatbuffers::Offset<gpuless::execution::ReturnBuffer>>(*return_buffers) : 0;
  return gpuless::execution::CreateExecutionAnswer(
      _fbb,
      status,
      return_buffers__);
}

struct CUdeviceAttributeValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CUdeviceAttributeValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ATTRIBUTE = 4,
    VT_VALUE = 6
  };
  CUdeviceAttribute attribute() const {
    return static_cast<CUdeviceAttribute>(GetField<int32_t>(VT_ATTRIBUTE, 0));
  }
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ATTRIBUTE) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct CUdeviceAttributeValueBuilder {
  typedef CUdeviceAttributeValue Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_attribute(CUdeviceAttribute attribute) {
    fbb_.AddElement<int32_t>(CUdeviceAttributeValue::VT_ATTRIBUTE, static_cast<int32_t>(attribute), 0);
  }
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(CUdeviceAttributeValue::VT_VALUE, value, 0);
  }
  explicit CUdeviceAttributeValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CUdeviceAttributeValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CUdeviceAttributeValue>(end);
    return o;
  }
};

inline flatbuffers::Offset<CUdeviceAttributeValue> CreateCUdeviceAttributeValue(
    flatbuffers::FlatBufferBuilder &_fbb,
    CUdeviceAttribute attribute = CUdeviceAttribute_FLATBUFFER_DEFAULT_VALUE,
    int32_t value = 0) {
  CUdeviceAttributeValueBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_attribute(attribute);
  return builder_.Finish();
}

struct AttributesAnswer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttributesAnswerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATUS = 4,
    VT_ATTRIBUTES = 6
  };
  gpuless::execution::Status status() const {
    return static_cast<gpuless::execution::Status>(GetField<int8_t>(VT_STATUS, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<gpuless::execution::CUdeviceAttributeValue>> *attributes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<gpuless::execution::CUdeviceAttributeValue>> *>(VT_ATTRIBUTES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_STATUS) &&
           VerifyOffset(verifier, VT_ATTRIBUTES) &&
           verifier.VerifyVector(attributes()) &&
           verifier.VerifyVectorOfTables(attributes()) &&
           verifier.EndTable();
  }
};

struct AttributesAnswerBuilder {
  typedef AttributesAnswer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status(gpuless::execution::Status status) {
    fbb_.AddElement<int8_t>(AttributesAnswer::VT_STATUS, static_cast<int8_t>(status), 0);
  }
  void add_attributes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<gpuless::execution::CUdeviceAttributeValue>>> attributes) {
    fbb_.AddOffset(AttributesAnswer::VT_ATTRIBUTES, attributes);
  }
  explicit AttributesAnswerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AttributesAnswer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AttributesAnswer>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttributesAnswer> CreateAttributesAnswer(
    flatbuffers::FlatBufferBuilder &_fbb,
    gpuless::execution::Status status = gpuless::execution::Status_OK,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<gpuless::execution::CUdeviceAttributeValue>>> attributes = 0) {
  AttributesAnswerBuilder builder_(_fbb);
  builder_.add_attributes(attributes);
  builder_.add_status(status);
  return builder_.Finish();
}

inline flatbuffers::Offset<AttributesAnswer> CreateAttributesAnswerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    gpuless::execution::Status status = gpuless::execution::Status_OK,
    const std::vector<flatbuffers::Offset<gpuless::execution::CUdeviceAttributeValue>> *attributes = nullptr) {
  auto attributes__ = attributes ? _fbb.CreateVector<flatbuffers::Offset<gpuless::execution::CUdeviceAttributeValue>>(*attributes) : 0;
  return gpuless::execution::CreateAttributesAnswer(
      _fbb,
      status,
      attributes__);
}

struct AttributesRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttributesRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AttributesRequestBuilder {
  typedef AttributesRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AttributesRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AttributesRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AttributesRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttributesRequest> CreateAttributesRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AttributesRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ProtocolMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProtocolMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  gpuless::execution::Message message_type() const {
    return static_cast<gpuless::execution::Message>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const gpuless::execution::ExecutionRequest *message_as_ExecutionRequest() const {
    return message_type() == gpuless::execution::Message_ExecutionRequest ? static_cast<const gpuless::execution::ExecutionRequest *>(message()) : nullptr;
  }
  const gpuless::execution::ExecutionAnswer *message_as_ExecutionAnswer() const {
    return message_type() == gpuless::execution::Message_ExecutionAnswer ? static_cast<const gpuless::execution::ExecutionAnswer *>(message()) : nullptr;
  }
  const gpuless::execution::AttributesRequest *message_as_AttributesRequest() const {
    return message_type() == gpuless::execution::Message_AttributesRequest ? static_cast<const gpuless::execution::AttributesRequest *>(message()) : nullptr;
  }
  const gpuless::execution::AttributesAnswer *message_as_AttributesAnswer() const {
    return message_type() == gpuless::execution::Message_AttributesAnswer ? static_cast<const gpuless::execution::AttributesAnswer *>(message()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyMessage(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const gpuless::execution::ExecutionRequest *ProtocolMessage::message_as<gpuless::execution::ExecutionRequest>() const {
  return message_as_ExecutionRequest();
}

template<> inline const gpuless::execution::ExecutionAnswer *ProtocolMessage::message_as<gpuless::execution::ExecutionAnswer>() const {
  return message_as_ExecutionAnswer();
}

template<> inline const gpuless::execution::AttributesRequest *ProtocolMessage::message_as<gpuless::execution::AttributesRequest>() const {
  return message_as_AttributesRequest();
}

template<> inline const gpuless::execution::AttributesAnswer *ProtocolMessage::message_as<gpuless::execution::AttributesAnswer>() const {
  return message_as_AttributesAnswer();
}

struct ProtocolMessageBuilder {
  typedef ProtocolMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(gpuless::execution::Message message_type) {
    fbb_.AddElement<uint8_t>(ProtocolMessage::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(ProtocolMessage::VT_MESSAGE, message);
  }
  explicit ProtocolMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ProtocolMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProtocolMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProtocolMessage> CreateProtocolMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    gpuless::execution::Message message_type = gpuless::execution::Message_NONE,
    flatbuffers::Offset<void> message = 0) {
  ProtocolMessageBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

inline bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type) {
  switch (type) {
    case Message_NONE: {
      return true;
    }
    case Message_ExecutionRequest: {
      auto ptr = reinterpret_cast<const gpuless::execution::ExecutionRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_ExecutionAnswer: {
      auto ptr = reinterpret_cast<const gpuless::execution::ExecutionAnswer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_AttributesRequest: {
      auto ptr = reinterpret_cast<const gpuless::execution::AttributesRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_AttributesAnswer: {
      auto ptr = reinterpret_cast<const gpuless::execution::AttributesAnswer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessage(
        verifier,  values->Get(i), types->GetEnum<Message>(i))) {
      return false;
    }
  }
  return true;
}

inline const gpuless::execution::ProtocolMessage *GetProtocolMessage(const void *buf) {
  return flatbuffers::GetRoot<gpuless::execution::ProtocolMessage>(buf);
}

inline const gpuless::execution::ProtocolMessage *GetSizePrefixedProtocolMessage(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<gpuless::execution::ProtocolMessage>(buf);
}

inline bool VerifyProtocolMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<gpuless::execution::ProtocolMessage>(nullptr);
}

inline bool VerifySizePrefixedProtocolMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<gpuless::execution::ProtocolMessage>(nullptr);
}

inline void FinishProtocolMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<gpuless::execution::ProtocolMessage> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedProtocolMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<gpuless::execution::ProtocolMessage> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace execution
}  // namespace gpuless

#endif  // FLATBUFFERS_GENERATED_EXECUTIONPROTOCOL_GPULESS_EXECUTION_H_
