// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TRACEEXECUTIONPROTOCOL_GPULESS_H_
#define FLATBUFFERS_GENERATED_TRACEEXECUTIONPROTOCOL_GPULESS_H_

#include "flatbuffers/flatbuffers.h"

#include "cuda_runtime_calls_generated.h"

namespace gpuless {

struct FBCudaApiCall;
struct FBCudaApiCallBuilder;

struct FBNewModule;
struct FBNewModuleBuilder;

struct FBNewFunction;
struct FBNewFunctionBuilder;

struct FBTraceExecRequest;
struct FBTraceExecRequestBuilder;

struct FBTraceExecResponse;
struct FBTraceExecResponseBuilder;

struct FBProtocolMessage;
struct FBProtocolMessageBuilder;

enum FBStatus : int8_t {
  FBStatus_OK = 0,
  FBStatus_FAILURE = 1,
  FBStatus_MIN = FBStatus_OK,
  FBStatus_MAX = FBStatus_FAILURE
};

inline const FBStatus (&EnumValuesFBStatus())[2] {
  static const FBStatus values[] = {
    FBStatus_OK,
    FBStatus_FAILURE
  };
  return values;
}

inline const char * const *EnumNamesFBStatus() {
  static const char * const names[3] = {
    "OK",
    "FAILURE",
    nullptr
  };
  return names;
}

inline const char *EnumNameFBStatus(FBStatus e) {
  if (flatbuffers::IsOutRange(e, FBStatus_OK, FBStatus_FAILURE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFBStatus()[index];
}

enum FBCudaApiCallUnion : uint8_t {
  FBCudaApiCallUnion_NONE = 0,
  FBCudaApiCallUnion_FBCudaMalloc = 1,
  FBCudaApiCallUnion_FBCudaMemcpyH2D = 2,
  FBCudaApiCallUnion_FBCudaMemcpyD2H = 3,
  FBCudaApiCallUnion_FBCudaLaunchKernel = 4,
  FBCudaApiCallUnion_FBCudaFree = 5,
  FBCudaApiCallUnion_MIN = FBCudaApiCallUnion_NONE,
  FBCudaApiCallUnion_MAX = FBCudaApiCallUnion_FBCudaFree
};

inline const FBCudaApiCallUnion (&EnumValuesFBCudaApiCallUnion())[6] {
  static const FBCudaApiCallUnion values[] = {
    FBCudaApiCallUnion_NONE,
    FBCudaApiCallUnion_FBCudaMalloc,
    FBCudaApiCallUnion_FBCudaMemcpyH2D,
    FBCudaApiCallUnion_FBCudaMemcpyD2H,
    FBCudaApiCallUnion_FBCudaLaunchKernel,
    FBCudaApiCallUnion_FBCudaFree
  };
  return values;
}

inline const char * const *EnumNamesFBCudaApiCallUnion() {
  static const char * const names[7] = {
    "NONE",
    "FBCudaMalloc",
    "FBCudaMemcpyH2D",
    "FBCudaMemcpyD2H",
    "FBCudaLaunchKernel",
    "FBCudaFree",
    nullptr
  };
  return names;
}

inline const char *EnumNameFBCudaApiCallUnion(FBCudaApiCallUnion e) {
  if (flatbuffers::IsOutRange(e, FBCudaApiCallUnion_NONE, FBCudaApiCallUnion_FBCudaFree)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFBCudaApiCallUnion()[index];
}

template<typename T> struct FBCudaApiCallUnionTraits {
  static const FBCudaApiCallUnion enum_value = FBCudaApiCallUnion_NONE;
};

template<> struct FBCudaApiCallUnionTraits<FBCudaMalloc> {
  static const FBCudaApiCallUnion enum_value = FBCudaApiCallUnion_FBCudaMalloc;
};

template<> struct FBCudaApiCallUnionTraits<FBCudaMemcpyH2D> {
  static const FBCudaApiCallUnion enum_value = FBCudaApiCallUnion_FBCudaMemcpyH2D;
};

template<> struct FBCudaApiCallUnionTraits<FBCudaMemcpyD2H> {
  static const FBCudaApiCallUnion enum_value = FBCudaApiCallUnion_FBCudaMemcpyD2H;
};

template<> struct FBCudaApiCallUnionTraits<FBCudaLaunchKernel> {
  static const FBCudaApiCallUnion enum_value = FBCudaApiCallUnion_FBCudaLaunchKernel;
};

template<> struct FBCudaApiCallUnionTraits<FBCudaFree> {
  static const FBCudaApiCallUnion enum_value = FBCudaApiCallUnion_FBCudaFree;
};

bool VerifyFBCudaApiCallUnion(flatbuffers::Verifier &verifier, const void *obj, FBCudaApiCallUnion type);
bool VerifyFBCudaApiCallUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum FBMessage : uint8_t {
  FBMessage_NONE = 0,
  FBMessage_FBTraceExecRequest = 1,
  FBMessage_FBTraceExecResponse = 2,
  FBMessage_MIN = FBMessage_NONE,
  FBMessage_MAX = FBMessage_FBTraceExecResponse
};

inline const FBMessage (&EnumValuesFBMessage())[3] {
  static const FBMessage values[] = {
    FBMessage_NONE,
    FBMessage_FBTraceExecRequest,
    FBMessage_FBTraceExecResponse
  };
  return values;
}

inline const char * const *EnumNamesFBMessage() {
  static const char * const names[4] = {
    "NONE",
    "FBTraceExecRequest",
    "FBTraceExecResponse",
    nullptr
  };
  return names;
}

inline const char *EnumNameFBMessage(FBMessage e) {
  if (flatbuffers::IsOutRange(e, FBMessage_NONE, FBMessage_FBTraceExecResponse)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFBMessage()[index];
}

template<typename T> struct FBMessageTraits {
  static const FBMessage enum_value = FBMessage_NONE;
};

template<> struct FBMessageTraits<gpuless::FBTraceExecRequest> {
  static const FBMessage enum_value = FBMessage_FBTraceExecRequest;
};

template<> struct FBMessageTraits<gpuless::FBTraceExecResponse> {
  static const FBMessage enum_value = FBMessage_FBTraceExecResponse;
};

bool VerifyFBMessage(flatbuffers::Verifier &verifier, const void *obj, FBMessage type);
bool VerifyFBMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct FBCudaApiCall FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FBCudaApiCallBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_API_CALL_TYPE = 4,
    VT_API_CALL = 6
  };
  gpuless::FBCudaApiCallUnion api_call_type() const {
    return static_cast<gpuless::FBCudaApiCallUnion>(GetField<uint8_t>(VT_API_CALL_TYPE, 0));
  }
  const void *api_call() const {
    return GetPointer<const void *>(VT_API_CALL);
  }
  template<typename T> const T *api_call_as() const;
  const FBCudaMalloc *api_call_as_FBCudaMalloc() const {
    return api_call_type() == gpuless::FBCudaApiCallUnion_FBCudaMalloc ? static_cast<const FBCudaMalloc *>(api_call()) : nullptr;
  }
  const FBCudaMemcpyH2D *api_call_as_FBCudaMemcpyH2D() const {
    return api_call_type() == gpuless::FBCudaApiCallUnion_FBCudaMemcpyH2D ? static_cast<const FBCudaMemcpyH2D *>(api_call()) : nullptr;
  }
  const FBCudaMemcpyD2H *api_call_as_FBCudaMemcpyD2H() const {
    return api_call_type() == gpuless::FBCudaApiCallUnion_FBCudaMemcpyD2H ? static_cast<const FBCudaMemcpyD2H *>(api_call()) : nullptr;
  }
  const FBCudaLaunchKernel *api_call_as_FBCudaLaunchKernel() const {
    return api_call_type() == gpuless::FBCudaApiCallUnion_FBCudaLaunchKernel ? static_cast<const FBCudaLaunchKernel *>(api_call()) : nullptr;
  }
  const FBCudaFree *api_call_as_FBCudaFree() const {
    return api_call_type() == gpuless::FBCudaApiCallUnion_FBCudaFree ? static_cast<const FBCudaFree *>(api_call()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_API_CALL_TYPE) &&
           VerifyOffset(verifier, VT_API_CALL) &&
           VerifyFBCudaApiCallUnion(verifier, api_call(), api_call_type()) &&
           verifier.EndTable();
  }
};

template<> inline const FBCudaMalloc *FBCudaApiCall::api_call_as<FBCudaMalloc>() const {
  return api_call_as_FBCudaMalloc();
}

template<> inline const FBCudaMemcpyH2D *FBCudaApiCall::api_call_as<FBCudaMemcpyH2D>() const {
  return api_call_as_FBCudaMemcpyH2D();
}

template<> inline const FBCudaMemcpyD2H *FBCudaApiCall::api_call_as<FBCudaMemcpyD2H>() const {
  return api_call_as_FBCudaMemcpyD2H();
}

template<> inline const FBCudaLaunchKernel *FBCudaApiCall::api_call_as<FBCudaLaunchKernel>() const {
  return api_call_as_FBCudaLaunchKernel();
}

template<> inline const FBCudaFree *FBCudaApiCall::api_call_as<FBCudaFree>() const {
  return api_call_as_FBCudaFree();
}

struct FBCudaApiCallBuilder {
  typedef FBCudaApiCall Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_api_call_type(gpuless::FBCudaApiCallUnion api_call_type) {
    fbb_.AddElement<uint8_t>(FBCudaApiCall::VT_API_CALL_TYPE, static_cast<uint8_t>(api_call_type), 0);
  }
  void add_api_call(flatbuffers::Offset<void> api_call) {
    fbb_.AddOffset(FBCudaApiCall::VT_API_CALL, api_call);
  }
  explicit FBCudaApiCallBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FBCudaApiCall> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FBCudaApiCall>(end);
    return o;
  }
};

inline flatbuffers::Offset<FBCudaApiCall> CreateFBCudaApiCall(
    flatbuffers::FlatBufferBuilder &_fbb,
    gpuless::FBCudaApiCallUnion api_call_type = gpuless::FBCudaApiCallUnion_NONE,
    flatbuffers::Offset<void> api_call = 0) {
  FBCudaApiCallBuilder builder_(_fbb);
  builder_.add_api_call(api_call);
  builder_.add_api_call_type(api_call_type);
  return builder_.Finish();
}

struct FBNewModule FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FBNewModuleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUFFER = 4,
    VT_MODULE_ID = 6
  };
  const flatbuffers::Vector<uint8_t> *buffer() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BUFFER);
  }
  uint64_t module_id() const {
    return GetField<uint64_t>(VT_MODULE_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BUFFER) &&
           verifier.VerifyVector(buffer()) &&
           VerifyField<uint64_t>(verifier, VT_MODULE_ID) &&
           verifier.EndTable();
  }
};

struct FBNewModuleBuilder {
  typedef FBNewModule Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_buffer(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> buffer) {
    fbb_.AddOffset(FBNewModule::VT_BUFFER, buffer);
  }
  void add_module_id(uint64_t module_id) {
    fbb_.AddElement<uint64_t>(FBNewModule::VT_MODULE_ID, module_id, 0);
  }
  explicit FBNewModuleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FBNewModule> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FBNewModule>(end);
    return o;
  }
};

inline flatbuffers::Offset<FBNewModule> CreateFBNewModule(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> buffer = 0,
    uint64_t module_id = 0) {
  FBNewModuleBuilder builder_(_fbb);
  builder_.add_module_id(module_id);
  builder_.add_buffer(buffer);
  return builder_.Finish();
}

inline flatbuffers::Offset<FBNewModule> CreateFBNewModuleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *buffer = nullptr,
    uint64_t module_id = 0) {
  auto buffer__ = buffer ? _fbb.CreateVector<uint8_t>(*buffer) : 0;
  return gpuless::CreateFBNewModule(
      _fbb,
      buffer__,
      module_id);
}

struct FBNewFunction FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FBNewFunctionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SYMBOL = 4,
    VT_MODULE_ID = 6
  };
  const flatbuffers::String *symbol() const {
    return GetPointer<const flatbuffers::String *>(VT_SYMBOL);
  }
  uint64_t module_id() const {
    return GetField<uint64_t>(VT_MODULE_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(symbol()) &&
           VerifyField<uint64_t>(verifier, VT_MODULE_ID) &&
           verifier.EndTable();
  }
};

struct FBNewFunctionBuilder {
  typedef FBNewFunction Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(FBNewFunction::VT_SYMBOL, symbol);
  }
  void add_module_id(uint64_t module_id) {
    fbb_.AddElement<uint64_t>(FBNewFunction::VT_MODULE_ID, module_id, 0);
  }
  explicit FBNewFunctionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FBNewFunction> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FBNewFunction>(end);
    return o;
  }
};

inline flatbuffers::Offset<FBNewFunction> CreateFBNewFunction(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    uint64_t module_id = 0) {
  FBNewFunctionBuilder builder_(_fbb);
  builder_.add_module_id(module_id);
  builder_.add_symbol(symbol);
  return builder_.Finish();
}

inline flatbuffers::Offset<FBNewFunction> CreateFBNewFunctionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *symbol = nullptr,
    uint64_t module_id = 0) {
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  return gpuless::CreateFBNewFunction(
      _fbb,
      symbol__,
      module_id);
}

struct FBTraceExecRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FBTraceExecRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRACE = 4,
    VT_NEW_MODULES = 6,
    VT_NEW_FUNCTIONS = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<gpuless::FBCudaApiCall>> *trace() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<gpuless::FBCudaApiCall>> *>(VT_TRACE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<gpuless::FBNewModule>> *new_modules() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<gpuless::FBNewModule>> *>(VT_NEW_MODULES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<gpuless::FBNewFunction>> *new_functions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<gpuless::FBNewFunction>> *>(VT_NEW_FUNCTIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TRACE) &&
           verifier.VerifyVector(trace()) &&
           verifier.VerifyVectorOfTables(trace()) &&
           VerifyOffset(verifier, VT_NEW_MODULES) &&
           verifier.VerifyVector(new_modules()) &&
           verifier.VerifyVectorOfTables(new_modules()) &&
           VerifyOffset(verifier, VT_NEW_FUNCTIONS) &&
           verifier.VerifyVector(new_functions()) &&
           verifier.VerifyVectorOfTables(new_functions()) &&
           verifier.EndTable();
  }
};

struct FBTraceExecRequestBuilder {
  typedef FBTraceExecRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_trace(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<gpuless::FBCudaApiCall>>> trace) {
    fbb_.AddOffset(FBTraceExecRequest::VT_TRACE, trace);
  }
  void add_new_modules(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<gpuless::FBNewModule>>> new_modules) {
    fbb_.AddOffset(FBTraceExecRequest::VT_NEW_MODULES, new_modules);
  }
  void add_new_functions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<gpuless::FBNewFunction>>> new_functions) {
    fbb_.AddOffset(FBTraceExecRequest::VT_NEW_FUNCTIONS, new_functions);
  }
  explicit FBTraceExecRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FBTraceExecRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FBTraceExecRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<FBTraceExecRequest> CreateFBTraceExecRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<gpuless::FBCudaApiCall>>> trace = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<gpuless::FBNewModule>>> new_modules = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<gpuless::FBNewFunction>>> new_functions = 0) {
  FBTraceExecRequestBuilder builder_(_fbb);
  builder_.add_new_functions(new_functions);
  builder_.add_new_modules(new_modules);
  builder_.add_trace(trace);
  return builder_.Finish();
}

inline flatbuffers::Offset<FBTraceExecRequest> CreateFBTraceExecRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<gpuless::FBCudaApiCall>> *trace = nullptr,
    const std::vector<flatbuffers::Offset<gpuless::FBNewModule>> *new_modules = nullptr,
    const std::vector<flatbuffers::Offset<gpuless::FBNewFunction>> *new_functions = nullptr) {
  auto trace__ = trace ? _fbb.CreateVector<flatbuffers::Offset<gpuless::FBCudaApiCall>>(*trace) : 0;
  auto new_modules__ = new_modules ? _fbb.CreateVector<flatbuffers::Offset<gpuless::FBNewModule>>(*new_modules) : 0;
  auto new_functions__ = new_functions ? _fbb.CreateVector<flatbuffers::Offset<gpuless::FBNewFunction>>(*new_functions) : 0;
  return gpuless::CreateFBTraceExecRequest(
      _fbb,
      trace__,
      new_modules__,
      new_functions__);
}

struct FBTraceExecResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FBTraceExecResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATUS = 4,
    VT_TRACE_TOP = 6
  };
  gpuless::FBStatus status() const {
    return static_cast<gpuless::FBStatus>(GetField<int8_t>(VT_STATUS, 0));
  }
  const gpuless::FBCudaApiCall *trace_top() const {
    return GetPointer<const gpuless::FBCudaApiCall *>(VT_TRACE_TOP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_STATUS) &&
           VerifyOffset(verifier, VT_TRACE_TOP) &&
           verifier.VerifyTable(trace_top()) &&
           verifier.EndTable();
  }
};

struct FBTraceExecResponseBuilder {
  typedef FBTraceExecResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status(gpuless::FBStatus status) {
    fbb_.AddElement<int8_t>(FBTraceExecResponse::VT_STATUS, static_cast<int8_t>(status), 0);
  }
  void add_trace_top(flatbuffers::Offset<gpuless::FBCudaApiCall> trace_top) {
    fbb_.AddOffset(FBTraceExecResponse::VT_TRACE_TOP, trace_top);
  }
  explicit FBTraceExecResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FBTraceExecResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FBTraceExecResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<FBTraceExecResponse> CreateFBTraceExecResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    gpuless::FBStatus status = gpuless::FBStatus_OK,
    flatbuffers::Offset<gpuless::FBCudaApiCall> trace_top = 0) {
  FBTraceExecResponseBuilder builder_(_fbb);
  builder_.add_trace_top(trace_top);
  builder_.add_status(status);
  return builder_.Finish();
}

struct FBProtocolMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FBProtocolMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  gpuless::FBMessage message_type() const {
    return static_cast<gpuless::FBMessage>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const gpuless::FBTraceExecRequest *message_as_FBTraceExecRequest() const {
    return message_type() == gpuless::FBMessage_FBTraceExecRequest ? static_cast<const gpuless::FBTraceExecRequest *>(message()) : nullptr;
  }
  const gpuless::FBTraceExecResponse *message_as_FBTraceExecResponse() const {
    return message_type() == gpuless::FBMessage_FBTraceExecResponse ? static_cast<const gpuless::FBTraceExecResponse *>(message()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyFBMessage(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const gpuless::FBTraceExecRequest *FBProtocolMessage::message_as<gpuless::FBTraceExecRequest>() const {
  return message_as_FBTraceExecRequest();
}

template<> inline const gpuless::FBTraceExecResponse *FBProtocolMessage::message_as<gpuless::FBTraceExecResponse>() const {
  return message_as_FBTraceExecResponse();
}

struct FBProtocolMessageBuilder {
  typedef FBProtocolMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(gpuless::FBMessage message_type) {
    fbb_.AddElement<uint8_t>(FBProtocolMessage::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(FBProtocolMessage::VT_MESSAGE, message);
  }
  explicit FBProtocolMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FBProtocolMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FBProtocolMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<FBProtocolMessage> CreateFBProtocolMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    gpuless::FBMessage message_type = gpuless::FBMessage_NONE,
    flatbuffers::Offset<void> message = 0) {
  FBProtocolMessageBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

inline bool VerifyFBCudaApiCallUnion(flatbuffers::Verifier &verifier, const void *obj, FBCudaApiCallUnion type) {
  switch (type) {
    case FBCudaApiCallUnion_NONE: {
      return true;
    }
    case FBCudaApiCallUnion_FBCudaMalloc: {
      auto ptr = reinterpret_cast<const FBCudaMalloc *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case FBCudaApiCallUnion_FBCudaMemcpyH2D: {
      auto ptr = reinterpret_cast<const FBCudaMemcpyH2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case FBCudaApiCallUnion_FBCudaMemcpyD2H: {
      auto ptr = reinterpret_cast<const FBCudaMemcpyD2H *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case FBCudaApiCallUnion_FBCudaLaunchKernel: {
      auto ptr = reinterpret_cast<const FBCudaLaunchKernel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case FBCudaApiCallUnion_FBCudaFree: {
      auto ptr = reinterpret_cast<const FBCudaFree *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyFBCudaApiCallUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyFBCudaApiCallUnion(
        verifier,  values->Get(i), types->GetEnum<FBCudaApiCallUnion>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyFBMessage(flatbuffers::Verifier &verifier, const void *obj, FBMessage type) {
  switch (type) {
    case FBMessage_NONE: {
      return true;
    }
    case FBMessage_FBTraceExecRequest: {
      auto ptr = reinterpret_cast<const gpuless::FBTraceExecRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case FBMessage_FBTraceExecResponse: {
      auto ptr = reinterpret_cast<const gpuless::FBTraceExecResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyFBMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyFBMessage(
        verifier,  values->Get(i), types->GetEnum<FBMessage>(i))) {
      return false;
    }
  }
  return true;
}

inline const gpuless::FBProtocolMessage *GetFBProtocolMessage(const void *buf) {
  return flatbuffers::GetRoot<gpuless::FBProtocolMessage>(buf);
}

inline const gpuless::FBProtocolMessage *GetSizePrefixedFBProtocolMessage(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<gpuless::FBProtocolMessage>(buf);
}

inline bool VerifyFBProtocolMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<gpuless::FBProtocolMessage>(nullptr);
}

inline bool VerifySizePrefixedFBProtocolMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<gpuless::FBProtocolMessage>(nullptr);
}

inline void FinishFBProtocolMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<gpuless::FBProtocolMessage> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedFBProtocolMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<gpuless::FBProtocolMessage> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace gpuless

#endif  // FLATBUFFERS_GENERATED_TRACEEXECUTIONPROTOCOL_GPULESS_H_
